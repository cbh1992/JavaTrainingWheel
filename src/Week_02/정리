산술연산자 : +, -, *, /, %
비교연산자 : >, < >=, <=, ==, !=
논리연산자 : && and, || or, ! not
대입연산자 : =, ++, --
기타연산자 : (type) 형 변환, ? : 삼항, instance of

연산자 우선순위 : 산술 > 비교 > 논리 > 대입
단, 괄호로 감싸면 괄호안이 우선 처리된다

연산시 피연산자의 타입이 다르면 큰쪽으로 일치시킨다
double > float > long > int > short

비트 연산
최소단위 Bit를 사용하여 가장 빠름
Bit 자릿수를 옮기는것을 비트 연산이라고 함
<<는 왼쪽으로, >>는 오른쪽으로
0,1은 이진수 값이어서 왼쪽으로 옮기면 2배수 곱셈연산, 오른쪽으로 옮기면 2배수 나눗셈 연산

switch/case
- `switch(피연산자)` `{ case(조건): (연산) }` 이러한 형태로 많이 쓰입니다.
- `switch 피연산자`가 `case 조건`을 만족하면 `case:` 뒤에 명시되어 있는 연산을 수행합니다.
- `case(조건): (연산)` 은 여러개를 설정할 수 있습니다.
    - 각 case 의 연산문 마지막에는 `break;` 를 꼭 넣어줘야 합니다!!
    - `break;` 문은 해당 case 의 연산문이 끝났다는것을 알려주어 switch 문을 종료시켜줍니다.

    <aside>
    만약 case 의 연산문 마지막에 `break;` 를 안넣어주면 어떻게 될까요?
    - case 의 연산문이 안끝났기때문에 `switch` 문 블럭이 끝날때 까지 전부 실행됩니다!
    </aside>

- `switch문` 중괄호 안의 제일 마지막에 `default: (연산)` 을 명시해주어 `case 조건`들이 모두 만족하지 않을때 수행할 연산을 정해주어야 합니다.
    - `default: (연산)` 은 아무것도 만족하지 않을때 수행하는 것이라, 없다면 생략해도 됩니다.

    - 차이점1. 복합조건
        - if 문은 복합조건을 지원합니다.
            - 복합조건 : 괄호`()`안에 조건 여러개를 지정하여 조건문을 수행할 수 있습니다.
        - switch 문은 피연산자 한개에 대한 조건만 지원합니다.
    - 차이점2. 코드중복
        - if 문은 상대적으로 코드중복이 많습니다.
        - switch 문은 코드중복이 적습니다.


배열은 참조형 변수이며 실제값이 아닌 값의 주소를 가진다
배열 변수간에 대입연산자  = 를 사용하여 복사하면 해당 주소값만 복사된다
주소값이 복사되기에 한쪽의 배열을 변경하면 다른쪽의 배열도 변경된다
이렇게 주소값은 복사하되 실제값은 1개로 유지되는걸 「얕은 복사」라고 한다

「깊은 복사」는 동일한 새로운 배열을 만드는걸 지칭한다
실제값을 지닌 배열의 기본형 값을 추출하여 복사한다
반복문 for 구문을 활용하여 하나씩 추출하는 방법과 여러 메소드를 활용하는 방법이 있다

컬렉션은 배열보다 다수의 참조형 데이터를 효과적으로 처리할 수 있음
컬렉션 종류 : List, Set, Queue, Map
List : 순서가 있는 데이터의 집합(중복 허용)
Set : 순서없는 데이터 집합(중복 불가)
Queue : 한쪽에서 입력, 다른쪽에서 출력
Map : 순서없는 Key, Value 쌍으로 이루어진 데이터 집합(Key값 중복 줄가)
컬렉션도 참조형 변수(int -> Integer, long -> Long, double -> Double)